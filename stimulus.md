# How To Add Stimulus to a Ruby on Rails Application

If you are working with a Ruby on Rails project, your requirements may include some interactivity with the HTML generated by your [view templates](https://guides.rubyonrails.org/v5.2/action_view_overview.html). If so, you have a few choices for how to implement this interactivity.

For example, you could implement a [JavaScript](https://www.digitalocean.com/community/tags/javascript?type=tutorials) framework like [React](https://reactjs.org/) or [Ember](https://emberjs.com/). If your requirements include handling state on the client side, or if you are concerned about performance issues associated with frequent queries to the server, then choosing one of these frameworks may make sense. Many Single Page Applications (SPAs) take this approach.

However, there are several considerations to keep in mind when implementing a framework that manages state and frequent updates on the client side: 1. It's possible for loading and conversion requirements — things like parsing JavaScript, and fetching and converting JSON to HTML — to limit performance. 2. Commitment to a framework may involve writing more code than your particular use case requires, particularly if you are looking for small-scale JavaScript enhancements. 3. State managed on both the client and server side can lead to a duplication of efforts, and increases the surface area for errors.

As an alternative, the team at [Basecamp](https://basecamp.com/) (the same team that wrote Rails) has created [Stimulus.js](https://stimulusjs.org/), which they describe as “a modest JavaScript framework for the HTML you already have.” Stimulus is meant to enhance a modern Rails application by working with server-side generated HTML. State lives in the [Document Object Model (DOM)](https://www.digitalocean.com/community/tutorial_series/understanding-the-dom-document-object-model), and the framework offers standard ways of interacting with elements and events in the DOM. It works side by side with [Turbolinks](https://github.com/turbolinks/turbolinks) (included in Rails 5+ by default) to improve performance and load times with code that is limited and scoped to a clearly defined purpose.

In this tutorial, you will install and use Stimulus to build on an existing Rails application that offers readers information about books. The application already has a model for handling book data, but you will add a nested resource for review about individual books, allowing users to build out a body of thoughts and opinions about books. This piece runs roughly parallel to [Nested Resources](./nested-resources.md), except that we will be using JavaScript to manipulate the position and appearance of review on the page. We will also take a slightly different approach to building out the review model itself.

## Step 1 — Creating a Nested Model
Our first step will be to create a nested review model, which we will associate with our existing book model. We will do this by creating Active Record associations between our models: review will belong to particular books, and each book can have multiple review.
To get started, navigate to the bookapp directory that you created for your Rails project in the prerequisites:
To create our review model, we'll use the rails generate command with the model generator. Type the following command to create the model:
With body:text, we're telling Rails to include a body field in the review database table — the table that maps to the review model. We're also including the :references keyword, which sets up an association between
            cd bookapp
     rails generate model review body:text book:references
     
 the book and review models. Specifically, this will ensure that a foreign key representing each book entry in the books database is added to the review database.
Once you have run the command, you will see output confirming the resources that Rails has generated for the application. Before moving on, you can check your database migration file to look at the relationship that now exists between your models and database tables. Use the following command to look at the contents of the file, making sure to substitute the timestamp on your own migration file for what's shown here:
You will see the following output:
       cat db/migrate/20190805132506_create_review.rb
 Output
  class Createreview < ActiveRecord::Migration[5.2]
  def change
create_table :review do |t|
t.text :body
t.references :book, foreign_key: true
      t.timestamps
    end
end end

  model_name_id
book_id
 review
  cat app/models/review.rb
 Output
  class review < ApplicationRecord
  belongs_to :book
end
 belongs_to
     belongs_to
has_many
book
review book
       app/models/sha
 has_many
 nano
    rk.rb
  nano app/models/book.rb
 As you can see, the table includes a column for a book foreign key. This key will take the form of — in our case, .
Rails has established the relationship between the models elsewhere as well. Take a look at the newly generated model with the following command:
The association sets up a relationship between models in which a single instance of the declaring model belongs to a single instance of the named model. In the case of our application, this means that a single review belongs to a single book.
Though Rails has already set the association in our model, we will need to specify a association in our model as well in order for that relationship to function properly.
To add the association to the model, open using or your favorite editor:
 
 Add the following line to the file to establish the relationship between books and review:
 ~/bookapp/app/models/book.rb
  class book < ApplicationRecord
  has_many :review
  validates :name, presence: true, uniqueness: true
  validates :facts, presence: true
end
One thing that is worth thinking about here is what happens to review once a particular book is deleted. We likely do not want the review associated with a deleted book persisting in the database. To ensure that any review associated with a given book are eliminated when that book is deleted, we can include the dependent option with the association.
Add the following code to the file to ensure that the destroy action on a given book deletes any associated review:
   ~/bookapp/app/models/book.rb
  class book < ApplicationRecord
has_many :review, dependent: :destroy
validates :name, presence: true, uniqueness: true validates :facts, presence: true
end
  
 Once you have finished making these changes, save and close the file. If you are working with nano , do this by pressing CTRL+X , Y , then ENTER .
You now have a model generated for your review, but you will also need a controller to coordinate between the data in your database and the HTML that's generated and presented to users.
Step 2 — Creating a Controller for a Nested Resource
Creating a review controller will involve setting a nested resource route in the application's main routing file and creating the controller file itself to specify the methods we want associated with particular actions.
To begin, open your config/routes.rb file to establish the relationship between your resourceful routes:
Currently, the file looks like this:
       nano config/routes.rb
  ~/bookapp/config/routes.rb
 Rails.application.routes.draw do
  resources :books
  root 'books#index'
  # For details on the DSL available within this file, see htt
p://guides.rubyonrails.org/routing.html
end
 
  We want to create a dependent relationship relationship between book and post resources. To do this, update your route declaration to make :books the parent of :review . Update the code in the file to look like the following:
    ~/bookapp/config/routes.rb
  Rails.application.routes.draw do resources :books do
    resources :review
  end
  root 'books#index'
  # For details on the DSL available within this file, see htt
p://guides.rubyonrails.org/routing.html
end
Save and close the file when you are finished editing.
Next, create a new file called app/controllers/review_controller.rb for the controller:
In this file, we'll define the methods that we will use to create and destroy individual review. However, because this is a nested model, we'll also want to create a local instance variable, @book, that we can use to associate particular review with specific books.
   nano app/controllers/review_controller.rb
 
 First, we can create the reviewController class itself, along with two
te methods: get_book , which will allow us to reference a particular book, and post_params, which gives us access to user-submitted information by way of the params method.
Add the following code to the file:
      ~/bookapp/app/controllers/review_controller.rb
  class reviewController < ApplicationController
  before_action :get_book
private
  def get_book
    @book = book.find(params[:book_id])
end
  def post_params
    params.require(:post).permit(:body, :book_id)
end end
You now have methods to get the particular book instances with which your review will be associated, using the :book_id key, and the data that users are inputting to create review. Both of these objects will now be
   priva
  
 available for the methods you will define to handle creating and destroying review.
Next, above the private methods, add the following code to the file to define your create and destroy methods:
    ~/bookapp/app/controllers/review_controller.rb
  .. .
def create
    @post = @book.review.create(post_params)
  end
  def destroy
    @post = @book.review.find(params[:id])
    @post.destroy
end .. .
These methods associate @post instances with particular @book instances, and use the collection methods that became available to us when we created the has_many association between books and review. Methods such as find and create allow us to target the collection of review associated with a particular book.
The finished file will look like this:
       
   Save and close the file when you are finished editing.
~/bookapp/app/controllers/review_controller.rb
 class reviewController < ApplicationController
  before_action :get_book
  def create
    @post = @book.review.create(post_params)
end
  def destroy
    @post = @book.review.find(params[:id])
    @post.destroy
end
private
  def get_book
    @book = book.find(params[:book_id])
end
  def post_params
    params.require(:post).permit(:body, :book_id)
end end

  With your controller and model in place, you can begin thinking about your view templates and how you will organize your application's generated HTML.
Step 6 — Creating the Stimulus Controller
Installing Stimulus created the app/javascript/controllers directory, which is where webpack is loading our application context from, so we will create our posts controller in this directory. This controller will include each of the methods we referenced in the previous step: - addBody() , to add new posts. - showAll() , to show older posts. - remove() , to remove posts from the current view. - upvote() , to attach an upvote icon to posts.
Create a file called posts_controller.js in the ers directory:
First, at the top of the file, extend Stimulus's built-in Controller class:
         nano app/javascript/controllers/posts_controller.js
  </div>
</div>
  app/javascript/controll
     
    Next, add the following target definitions to the file:
 ~/sharkapp/app/javascript/controllers/posts_cont
roller.js
  .. .
export default class extends Controller {
    static targets = ["body", "add", "show"]
}
Defining targets in this way will allow us to access them in our methods with the this.target-nameTarget property, which gives us the first matching target element. So, for example, to match the body data target defined in our targets array, we would use this.bodyTarget . This property allows us to manipulate things like input values or css styles.
Next, we can define the addBody method, which will control the appearance of new posts on the page. Add the following code below the target definitions to define this method:
    ~/sharkapp/app/javascript/controllers/posts_cont
roller.js
 import { Controller } from "stimulus"
export default class extends Controller {
}
 
    This method defines a content variable with the let keyword and sets it equal to the post input string that users entered into the posts form. It does this by virtue of the body data target that we attached to the <textarea> element in our form. Using this.bodyTarget to match this element, we can then use the value property that is associated with that element to set the value of content as the post input users have entered.
Next, the method adds this post input to the add target we added to the <ul > element below the form builder in the sharks/posts partial. It does this using the Element.insertAdjacentHTML() method, which will insert the content of the new post, set in the content variable, before the add target element. We've also enclosed the new post in an <li> element, so that new posts appear as bulleted list items.
              ~/sharkapp/app/javascript/controllers/posts_cont
roller.js
 .. .
export default class extends Controller {
    static targets = [ "body", "add", "show"]
    addBody() {
        let content = this.bodyTarget.value;
        this.addTarget.insertAdjacentHTML('beforebegin', "<li
>" + content + "</li>");
    }
}
 
 Next, below the addBody method, we can add the showAll method, which will control the appearance of older posts on the page:
   ~/sharkapp/app/javascript/controllers/posts_cont
roller.js
  .. .
export default class extends Controller { .. .
    addBody() {
        let content = this.bodyTarget.value;
        this.addTarget.insertAdjacentHTML('beforebegin', "<li
>" + content + "</li>");
    }
    showAll() {
        this.showTarget.style.visibility = "visible";
}
}
Here, we again use the this.target-nameTarget property to match our sho w target, which is attached to the <div> element with the sharks/all partial. We gave it a default style, "visibility:hidden" , so in this method, we simply change the style to "visible" . This will show the partial to users who have opted into seeing older posts.
       
 Below showAll, we'll next add an upvote method, to allow users to “upvote” posts on the page by attaching the free Font Awesome
le icon to a particular post.
Add the following code to define this method:
    ~/sharkapp/app/javascript/controllers/posts_cont
roller.js
  .. .
export default class extends Controller { .. .
    showAll() {
        this.showTarget.style.visibility = "visible";
}
    upvote() {
        let post = event.target.closest(".post");
        post.insertAdjacentHTML('beforeend', '<i class="fa fa-
check-circle"></i>');
    }
}
Here, we're creating a post variable that will target the closest <li> element with the class post — the class we attached to each <li> element
      check-circ
  
 in our loop iteration in sharks/all . This will target the closest post and add the check-circle icon just inside <li> element, after its last child.
Next, we'll use a similar method to hide posts on the page. Add the following code below the upvote method to define a remove method:
      ~/sharkapp/app/javascript/controllers/posts_cont
roller.js
  .. .
export default class extends Controller { .. .
    upvote() {
        let post = event.target.closest(".post");
        post.insertAdjacentHTML('beforeend', '<i class="fa fa-
check-circle"></i>');
    }
    remove() {
        let post = event.target.closest(".post");
        post.style.visibility = "hidden";
}
}
Once again, our post variable will target the closest <li> element with the class post. It will then set the visibility property to "hidden" to hide the
    
  post on the page.
The finished controller file will now look like this:

~/sharkapp/app/javascript/controllers/posts_cont
roller.js
   import { Controller } from "stimulus"
export default class extends Controller {
    static targets = ["body", "add", "show"]
    addBody() {
        let content = this.bodyTarget.value;
        this.addTarget.insertAdjacentHTML('beforebegin', "<li
>" + content + "</li>");
    }
    showAll() {
        this.showTarget.style.visibility = "visible";
}
    upvote() {
        let post = event.target.closest(".post");
        post.insertAdjacentHTML('beforeend', '<i class="fa fa-
check-circle"></i>');
    }
    remove() {
        let post = event.target.closest(".post");
 
         post.style.visibility = "hidden";
    }
}
 link_to
index
 index index
   nano app/views/sharks/index.html.erb
  button_to
javascript_pack_tag
    vascript_include_tag
    app/views/layouts/app
   lication.html.erb
    Save and close the file when you are finished editing.
With your Stimulus controller in place, you can move on to making some final changes to the view and testing your application.
